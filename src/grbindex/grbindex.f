!> @file
!> Write an index file.
!> @author IREDELL @date 1998-09-15
!
!> PROGRAM CREATES AN INDEX FILE FROM A GRIB FILE.
!>   THE INDEX FILE SERVES AS A TABLE OF CONTENTS FOR THE GRIB FILE,
!>   ENABLING QUICK ACCESS TO THE DATA.  THE GRIB FILE MUST BE UNBLOCKED,
!>   BUT THERE CAN BE A GAP BEFORE THE FIRST GRIB MESSAGE OF AT MOST
!>   32000 BYTES AND GAPS BETWEEN MESSAGES OF AT MOST 4000 BYTES.
!>   THE TWO FILE NAMES ARE RETRIEVED FROM THE COMMAND LINE ARGUMENTS.
!>   THE FIRST ARGUMENT IS THE NAME OF THE INPUT GRIB FILE.
!>   THE SECOND ARGUMENT IS THE NAME OF THE OUTPUT INDEX FILE.
!>   CURRENTLY, ONLY VERSION 1 OF GRIB CAN BE READ.
!>   VERSION 1 OF THE INDEX FILE HAS THE FOLLOWING FORMAT:
!>     81-BYTE S.LORD HEADER WITH 'GB1IX1' IN COLUMNS 42-47 FOLLOWED BY
!>     81-BYTE HEADER WITH NUMBER OF BYTES TO SKIP BEFORE INDEX RECORDS,
!>     NUMBER OF BYTES IN EACH INDEX RECORD, NUMBER OF INDEX RECORDS,
!>     AND GRIB FILE BASENAME WRITTEN IN FORMAT ('IX1FORM:',3I10,2X,A40).
!>     EACH FOLLOWING INDEX RECORD CORRESPONDS TO A GRIB MESSAGE
!>     AND HAS THE INTERNAL FORMAT:
!>     -  BYTE 001-004: BYTES TO SKIP IN DATA FILE BEFORE GRIB MESSAGE
!>     -  BYTE 005-008: BYTES TO SKIP IN MESSAGE BEFORE PDS
!>     -  BYTE 009-012: BYTES TO SKIP IN MESSAGE BEFORE GDS (0 IF NO GDS)
!>     -  BYTE 013-016: BYTES TO SKIP IN MESSAGE BEFORE BMS (0 IF NO BMS)
!>     -  BYTE 017-020: BYTES TO SKIP IN MESSAGE BEFORE BDS
!>     -  BYTE 021-024: BYTES TOTAL IN THE MESSAGE
!>     -  BYTE 025-025: GRIB VERSION NUMBER
!>     -  BYTE 026-053: PRODUCT DEFINITION SECTION (PDS)
!>     -  BYTE 054-095: GRID DEFINITION SECTION (GDS) (OR NULLS)
!>     -  BYTE 096-101: FIRST PART OF THE BIT MAP SECTION (BMS) (OR NULLS)
!>     -  BYTE 102-112: FIRST PART OF THE BINARY DATA SECTION (BDS)
!>     -  BYTE 113-172: (OPTIONAL) BYTES 41-100 OF THE PDS
!>     -  BYTE 173-184: (OPTIONAL) BYTES 29-40 OF THE PDS
!>     -  BYTE 185-320: (OPTIONAL) BYTES 43-178 OF THE GDS
!>
!> PROGRAM HISTORY LOG:
!> -  92-11-22  IREDELL
!> -  94-06-08  EBISUZAKI - ELIMINATE ISHELL CALLS
!> -  94-08-26  IREDELL   - 40 BYTE PDS EXTENSION
!> -  95-10-31  IREDELL   - CONSIDERABLY REDUCE I/O
!> -  96-10-31  IREDELL   - AUGMENTED OPTIONAL DEFINITIONS TO BYTE 320
!> - 1999-04-27  GILBERT   - Changed CALL EXIT(N) to CALL ERREXIT(N) so that
!>                         the proper error return value is passed back to
!>                         the shell.
!> - 2012-07-31  VUONG     - CHANGED HOSTNAME TO HOSTNAM
!>
!> USAGE: grbindex gribfile indexfile
!>
!> INPUT FILE:
!> -  gribfile     UNBLOCKED GRIB FILE
!>
!> OUTPUT FILE:
!> -  indexfile    UNBLOCKED INDEX FILE
!>
!> SUBPROGRAMS CALLED:
!>  - IARGC        COUNT THE COMMAND LINE ARGUMENTS
!>  - GETARG       GET COMMAND LINE ARGUMENT
!>  - WRGI1H       WRITE INDEX HEADERS
!>  - GETGIR       GET INDEX BUFFER
!>  - BAWRITE      BYTE-ADDRESSABLE WRITE
!>  - ERRMSG       WRITE A MESSAGE TO STDERR
!>  - ERREXIT      EXIT WITH RETURN CODE
!>
!> EXIT STATES:
!>  - COND =   0 - SUCCESSFUL RUN
!>  - COND =   1 - GRIB MESSAGE NOT FOUND
!>  - COND =   2 - INCORRECT ARGUMENTS
!>  - COND =   8 - ERROR ACCESSING FILE
!>
      PROGRAM GRBINDEX
      PARAMETER(MSK1=32000,MSK2=4000)
      CHARACTER CGB*256,CGI*256
      PARAMETER(MBUF=256*1024)
      CHARACTER CBUF(MBUF)
      CHARACTER CARG*300
      INTEGER NARG,IARGC
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!  GET ARGUMENTS
      NARG=IARGC()
      IF(NARG.NE.2) THEN
        CALL ERRMSG('grbindex:  Incorrect usage')
        CALL ERRMSG('Usage: grbindex gribfile indexfile')
        CALL ERREXIT(2)
      ENDIF
      CALL GETARG(1,CGB)
      NCGB=LEN_TRIM(CGB)
      CALL BAOPENR(11,CGB(1:NCGB),IOS)
      CALL BASETO(1,1)
      IF(IOS.NE.0) THEN
        LCARG=LEN('grbindex:  Error accessing file '//CGB(1:NCGB))
        CARG(1:LCARG)='grbindex:  Error accessing file '//CGB(1:NCGB)
        CALL ERRMSG(CARG(1:LCARG))
        CALL ERREXIT(8)
      ENDIF
      CALL GETARG(2,CGI)
      NCGI=LEN_TRIM(CGI)
      CALL BAOPEN(31,CGI(1:NCGI),IOS)
      IF(IOS.NE.0) THEN
        LCARG=LEN('grbindex:  Error accessing file '//CGI(1:NCGI))
        CARG(1:LCARG)='grbindex:  Error accessing file '//CGI(1:NCGI)
        CALL ERRMSG(CARG(1:LCARG))
        CALL ERREXIT(8)
      ENDIF
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!  WRITE INDEX FILE
      MNUM=0
      CALL GETGIR(11,MSK1,MSK2,MNUM,MBUF,CBUF,NLEN,NNUM,IRGI)
      IF(IRGI.GT.1.OR.NNUM.EQ.0) THEN
        CALL ERRMSG('grbindex:  No GRIB messages detected in file '
     &              //CGB(1:NCGB))
        CALL BACLOSE(11,IRET)
        CALL BACLOSE(31,IRET)
        CALL ERREXIT(1)
      ENDIF
      MNUM=MNUM+NNUM
      CALL WRGI1H(31,NLEN,MNUM,CGB(1:NCGB))
      IW=162
      CALL BAWRITE(31,IW,NLEN*NNUM,KW,CBUF)
      IW=IW+NLEN*NNUM
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!  EXTEND INDEX FILE IF INDEX BUFFER LENGTH GREATER THAN MBUF
      IF(IRGI.EQ.1) THEN
        DOWHILE(IRGI.EQ.1.AND.NNUM.GT.0)
          CALL GETGIR(11,MSK1,MSK2,MNUM,MBUF,CBUF,NLEN,NNUM,IRGI)
          IF(IRGI.LE.1.AND.NNUM.GT.0) THEN
            MNUM=MNUM+NNUM
            CALL BAWRITE(31,IW,NLEN*NNUM,KW,CBUF)
            IW=IW+NLEN*NNUM
          ENDIF
        ENDDO
        CALL WRGI1H(31,NLEN,MNUM,CGB(1:NCGB))
      ENDIF
      CALL BACLOSE(11,IRET)
      CALL BACLOSE(31,IRET)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END
!-----------------------------------------------------------------------
      SUBROUTINE WRGI1H(LUGI,NLEN,NNUM,CGB)
!$$$  SUBPROGRAM DOCUMENTATION BLOCK
!
! SUBPROGRAM: WRGI1H         WRITE INDEX HEADERS
!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 93-11-22
!
! ABSTRACT: THIS SUBPROGRAM WRITES TWO INDEX HEADERS.
!   CURRENTLY, THE LENGTH OF EACH INDEX RECORD IS 152.
!
! PROGRAM HISTORY LOG:
!   93-11-22  IREDELL
!   95-10-31  IREDELL   - MODULARIZE SYSTEM CALLS
! 2012-07-31  VUONG     - CHANGED HOSTNAME TO HOSTNAM
!
! USAGE:    CALL WRGI1H(LUGI,NLEN,NNUM,CGB)
!   INPUT ARGUMENTS:
!     LUGI         INTEGER LOGICAL UNIT OF OUTPUT INDEX FILE
!     NLEN         INTEGER LENGTH OF INDEX RECORDS
!     NNUM         INTEGER NUMBER OF INDEX RECORDS
!     CGB          CHARACTER NAME OF GRIB FILE
!
! SUBPROGRAMS CALLED:
!   NCBASE       GET BASENAME OF FILE
!   HOSTNAM      GET SYSTEM NAME
!   BAWRITE      BYTE-ADDRESSABLE WRITE
!
! ATTRIBUTES:
!   LANGUAGE: FORTRAN
!
!$$$
      CHARACTER CGB*(*)
#ifdef __GFORTRAN__
      CHARACTER CD8*8,CT10*10,HOSTNAME*15
      INTEGER ISTAT
#else
      CHARACTER CD8*8,CT10*10,HOSTNAM*15
#endif
      CHARACTER CHEAD(2)*81
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!  FILL FIRST 81-BYTE HEADER
      NCGB=LEN(CGB)
      NCGB1=NCBASE(CGB,NCGB)
      NCGB2=NCBASE(CGB,NCGB1-2)
      CALL DATE_AND_TIME(CD8,CT10)
      CHEAD(1)='!GFHDR!'
      CHEAD(1)(9:10)=' 1'
      CHEAD(1)(12:14)='  1'
      WRITE(CHEAD(1)(16:20),'(I5)') 162
      CHEAD(1)(22:31)=CD8(1:4)//'-'//CD8(5:6)//'-'//CD8(7:8)
      CHEAD(1)(33:40)=CT10(1:2)//':'//CT10(3:4)//':'//CT10(5:6)
      CHEAD(1)(42:47)='GB1IX1'
      CHEAD(1)(49:54)=CGB(NCGB2:NCGB1-2)
#ifdef __GFORTRAN__
      ISTAT=HOSTNM(HOSTNAME)
      IF(ISTAT.eq.0) THEN
        CHEAD(1)(56:70)='0000'
      ELSE
        CHEAD(1)(56:70)='0001'
      ENDIF
#else
      CHEAD(1)(56:70)=HOSTNAM(hostname)
#endif
!     print*,' CHEAD(1)(56:70) = ', CHEAD(1)(56:70)
      CHEAD(1)(72:80)='grbindex '
      CHEAD(1)(81:81)=CHAR(10)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!  FILL SECOND 81-BYTE HEADER
      CHEAD(2)='IX1FORM:'
      WRITE(CHEAD(2)(9:38),'(3I10)') 162,NLEN,NNUM
      CHEAD(2)(41:80)=CGB(NCGB1:NCGB)
      CHEAD(2)(81:81)=CHAR(10)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!  WRITE HEADERS AT BEGINNING OF INDEX FILE
      CALL BAWRITE(LUGI,0,162,KW,CHEAD)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END
!-----------------------------------------------------------------------
      FUNCTION NCBASE(C,N)
!$$$  SUBPROGRAM DOCUMENTATION BLOCK
!
! SUBPROGRAM: NCBASE         LOCATE BASENAME OF A FILE
!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 93-11-22
!
! ABSTRACT: THIS SUBPROGRAM LOCATES THE CHARACTER NUMBER AFTER THE LAST 
!   IN A CHARACTER STRING.  FOR UNIX FILENAMES, THE CHARACTER NUMBER
!   RETURNED MARKS THE BEGINNING OF THE BASENAME OF THE FILE.
!
! PROGRAM HISTORY LOG:
!   93-11-22  IREDELL
!
! USAGE:     ...=NCBASE(C,N)
!   INPUT ARGUMENTS:
!     C            CHARACTER STRING TO SEARCH
!     N            INTEGER LENGTH OF STRING
!
! ATTRIBUTES:
!   LANGUAGE: CRAY FORTRAN
!
!$$$
      CHARACTER C*(*)
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      K=N
      DOWHILE(K.GE.1.AND.C(K:K).NE.'/')
        K=K-1
      ENDDO
      NCBASE=K+1
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      RETURN
      END
